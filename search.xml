<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[华为手机通讯录]]></title>
    <url>%2FSonicHuang%2F49cc418f%2F</url>
    <content type="text"><![CDATA[在恢复出厂设置时，把老爸的华为麦芒通讯录搞丢了，但老人家保留了一个比较早的一个通讯录电子表格，自己录入的格式没有固定。我就想有没有比较方便的方法，用代码写一个通讯录，再导入到手机里面。 1.华为麦芒vcard格式 如上图vcard代码格式，一个联系人有一个片段, 中文人名是通过Quoted-printable方式编码 Quoted-printable或QP encoding，没有规范的中文译名，可译为可打印字符引用编码或使用可打印字符的编码。Quoted-printable是使用可打印的ASCII字符（如字母、数字与“=”）表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据[注 1]。这被定义为MIME content transfer encoding，用于e-mail。 看不懂！其实更简单的是这样： URL编码后把%换成=, 或者用utf-8编码把\x换成=如下： 12345&gt;&gt;&gt; import urllib.parse as up&gt;&gt;&gt; up.quote('黄学')'%E9%BB%84%E5%AD%A6'&gt;&gt;&gt; '黄学'.encode('utf-8')b'\xe9\xbb\x84\xe5\xad\xa6' 看起来用url编码更好一点。如果几个号码，就会用多行TEL;CELL:连接，电话号码的格式为：XXX XXXX XXXX 2.Python 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105'''本程序是通过输入联系人和电话号码然后转为为华为手机vcard的vcf文件，vcf文件可以直接上传到华为手机通讯录。'''import urllib.parse as upimport pickleimport os'''定义函数返回一个联系人的字典'''def contacts(): print('|--- 欢迎进入通讯录 ---|') print('|--- 1：查找联系人 ---|') print('|--- 2：增加或修改联系人 ---|') print('|--- 3：删除联系人 ---|') print('|--- 4：显示所有通讯录 ---|') print('|--- 5：保存并退出通讯录 ---|') #从内存中的二进制文件中读取联系人信息 try: with open('contact.txt', 'rb') as f2: contact = pickle.load(f2) except:#如果内存中没有文件者则赋值为一个空的字典 contact = &#123;&#125; while 1: no = input('请选择:')#input输入的都是字符串 #查找联系人 if no == '1': name = input('输入联系人姓名:') if name in contact:#联系人存在则打印他的号码 NO = contact[name] print('号码是: %s' % NO) else: print('联系人不存在!') #添加联系人 if no == '2': name = input('输入联系人姓名:') if name in contact:#如果联系人已经存在，打印联系电话，并询问是否要修改 print(' 联系人%s 的电话是: %s ' % (name, contact[name])) change = input('修改原号码回复y, 增加号码回复z, 什么都不做回复n:') if change == 'y': NO = input('输入新号码\(多个号码请用+连接\):') contact[name] = NO elif change == 'z': NO = input('输入号码\(多个号码请用+连接\):') contact[name] += NO else: NO = contact[name] print('号码是: %s' % NO) else: NO = input('输入联系人号码:') contact[name] = NO #删除联系人 if no == '3': name = input('输入联系人姓名:') if name in contact: del(contact[name]) else: print('联系人不存在.') #显示所有通讯录 if no == '4': if contact == &#123;&#125;: print('通讯录是空的.') else: for i in contact: print(i, ':', contact[i]) #保存并退出 if no == '5': print('保存并退出.') break #写入一个二进制文件保存数据 with open('contact.txt', 'wb') as f1: pickle.dump(contact, f1) return contact #返回字典数据'''清除之前的通讯录'''try: os.remove('newdata.vcf')except: pass#华为通讯录vcard代码字符串info1 = 'BEGIN:VCARD\nVERSION:2.1\nN;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;'info2 = ';;;\nFN;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:'info3 = '\nTEL;CELL:'info4 = '\nEND:VCARD\n'#通过输入通讯录后导出联系人的字典数据allno = contacts()#把字典数据转化为vcard代码并写入newdata.vcf文件for i in allno: name = i #通过列表解析式删除数据里面的空格 nostr = ''.join([x for x in allno[i] if x != ' ']) nolist = nostr.split('+') #如果有多个电话号码需要每个电话分离出来组成一个列表 list2 = [] for no in nolist: #注意vcard电话号码的格式数字之间有空格 no = no[:3] + ' ' + no[3:7] + ' ' + no[7:] list2 += [info3, no] #每个电话号码会形成单独一行 name = up.quote(name).replace('%', '=') #vcard联系人的名字是经过url编码后把%换成= with open('newdata.vcf', 'a') as file: #把通讯录代码写入vcard list1 = [info1, name, info2, name] list3 = [info4] data = ''.join(list1 + list2 + list3) file.write(data) 3.测试代码1234567891011121314151617181920212223242526&gt;&gt;&gt; ===================== RESTART: E:\python files\IDEL FILES\My py file\通讯录.py =====================|--- 欢迎进入通讯录 ---||--- 1：查找联系人 ---||--- 2：增加或修改联系人 ---||--- 3：删除联系人 ---||--- 4：显示所有通讯录 ---||--- 5：保存并退出通讯录 ---|请选择:4通讯录是空的.请选择:2输入联系人姓名:sonic输入联系人号码: 123 4567 8901请选择:2输入联系人姓名:joan输入联系人号码: 23456789012 +34567890123 + 98765 432312请选择:2输入联系人姓名:黄晓明输入联系人号码:34567890133请选择:4sonic : 123 4567 8901joan : 23456789012 +34567890123 + 98765 432312黄晓明 : 34567890133请选择:5保存并退出.&gt;&gt;&gt; 生成了两个文件，一个是保存了数据，一个是需要vcard文件可以直接上传到手机通讯录 生成的vcard文件内容： 1234567891011121314151617181920BEGIN:VCARDVERSION:2.1N;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;sonic;;;FN;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:sonicTEL;CELL:123 4567 8901END:VCARDBEGIN:VCARDVERSION:2.1N;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;joan;;;FN;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:joanTEL;CELL:234 5678 9012TEL;CELL:345 6789 0123TEL;CELL:987 6543 2312END:VCARDBEGIN:VCARDVERSION:2.1N;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;=E9=BB=84=E6=99=93=E6=98=8E;;;FN;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:=E9=BB=84=E6=99=93=E6=98=8ETEL;CELL:345 6789 0133END:VCARD 可以看到我在输入电话号码时的空格自动删除了，中文名被编码显示，英文字母没有变。代码写好了，以后再遇到相同的情况就不需要一个名字一个数字的敲了。如果有提供有格式的联系人名单，还可以直接读取名单信息自动生成vcard文件。同时，不同的手机生成的vcard文件格式略有差别，特别是在中文人名的处理方式上不同，不过都可以通过字符串的一些操作来实现。 4.通讯录vcard逆向操作如果我们得到一个vcard文件，需要马上知道里面是哪些人的电话号码就需要进行逆向操作了，这段代码不是我写的，来至记录一些最近用过的编码转换， 使用了正则表达式，还没有学到这个地方，先放在这里，后面再来研究。 123456789101112import reimport urllib.requestwith open('newdata.vcf') as file: vcf = file.read()vcf = vcf.replace('=\n=','=')names = re.findall('(=[\w=]+)',vcf)for name in names: if name[3:4]=='=': name_new = name.replace('=','%') name_new = urllib.request.unquote(name_new) vcf = vcf.replace(name,name_new,1)print(vcf) 运行后就会把上一个代码保存的文件转译过来，英文字符还是不变，只看中文名部分。 123456BEGIN:VCARDVERSION:2.1N;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;黄晓明;;;FN;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:黄晓明TEL;CELL:345 6789 0133END:VCARD 参考： 廖雪峰-字符串和编码 python之urlencode()，quote()及unquote() 记录一些最近用过的编码转换 总结： 本文用了urllib.parse, quote, pickle的用法 用了try..except..语句，join, split, 切片等对字符串进行操作]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>urllib.parse</tag>
        <tag>quote</tag>
        <tag>pickle</tag>
        <tag>正则表达式</tag>
        <tag>解析式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-Markdown-Typora操作问题解决方案记录]]></title>
    <url>%2FSonicHuang%2F4e074924%2F</url>
    <content type="text"><![CDATA[学习Markdown, Git, Typora第一天开始就出现很多操作上的问题，当时解决了后来又忘记。我想有必要把每次出现的问题记录一下。这篇文章将会持续更新。 从学习Markdown, Git, Typora第一天开始就出现很多操作上的问题，当时解决了后来又忘记。我想有必要把每次出现的问题记录一下。持续更新中。。。。 一. GitGit图解： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 1. diverged123# Your branch and &apos;origin/master&apos; have diverged,# and have 3 and 8 different commits each, respectively.# (use &quot;git pull&quot; to merge the remote branch into yours) 方法是： 12git fetch origingit reset --hard origin/master 还没有搞懂什么意思，结果是删除了工作区新的文件，恢复到到了之前的状态，状态正常。 2.Changes to be committed123456789$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: EXE文件/EvenRuiDict/EvenRuiDictionaryv1.0DeveloperSonicHuang.exe deleted: EXE文件/downloadcatpicture/CatPicDownloadv1.0DeveloperSonicHuang.exe 情况：这两个文件我改了名字重新提交了，但是提示缓存区有被删除的文件 解决方法：后来明白，本地进行的删除操作也要经过add, commit, push这个程序才能把所有记录和远程上的文件删除 123$ git add EXE文件/EvenRuiDict/EvenRuiDictionaryv1.0DeveloperSonicHuang.exe$ git commit -m &apos;删除EvenRuiDictionaryv1.0DeveloperSonicHuang.exe&apos;$ git push 1234567891011$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: EXE文件/downloadcatpicture/CatPicDownloadv1.0DeveloperSonicHuang.exeno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 可以看到第一个文件已经被删除了。第二个文件通过同样的方法删除掉。 参考Git删除文件 总结：凡是在本地删除文件都要提交删除操作，才能使所有本地和远程保持一致 3. LF will be replaced by CRLF12warning: LF will be replaced by CRLF in 通讯录.py.The file will have its original line endings in your working directory. 出现上述问题是在通讯录.py中使用了回车换行CRLF，而git是LF。表示在远端仓库保持了CRLF， 但是我的py文件都是回车换行，为什么只有这个文件有提示呢？搞不懂 参考： CRLF和LF在跨平台工作时候带来的烦恼以及解决方法 Git中的“LF will be replaced by CRLF”警告详解 二. Markdown(记录Typora不能表达的情况)1. 在段落中插入一小段代码，使用英文输入法反引号(~键)引用例如：Python的print() 2.三. Typora1.查看markdown源代码在typora编辑器左下角可以查看]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>typora</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫 喵星人图片下载工具]]></title>
    <url>%2FSonicHuang%2Fb0f08802%2F</url>
    <content type="text"><![CDATA[爬取喵星人图片下载网站用easygui提供交互界面输入图片尺寸并下载图片到本地。难度不大，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465'''本脚本是利用easygui提供的交互程序在placekitten.com下载喵星人图片'''import urllib.request as urimport easygui as egimport os#基础信息，默认尺寸msg = '输入图片尺寸'title = '喵星人图片下载 v1.0 Developer:SonicHuang'length = '400'width = '600'while True: size = eg.multenterbox(msg, title, ['长', '宽'], [length, width]) if size != None and size[0] != '' and size[1] != '': length = size[0] width = size[1] url = ''.join(['http://placekitten.com/g/', length, '/', width]) #处理网络异常和输入错误 try: #int()的参数必须为整数 int(length) int(width) response = ur.urlopen(url) except: #提示异常信息并返回主循环重新输入 eg.msgbox( '出错了！请检查输入的数据(必须为整数)和检查网络是否连接.', title, 'OK') continue else: #直接读取图片，并保存为一个临时图片 catimage = response.read() with open('temp.jpg', 'wb') as f1: f1.write(catimage) #预览临时图片 asksave = eg.buttonbox('预览\n需要保存请点击图片', title, ('保存图片', '重新输入尺寸', '退出'), 'temp.jpg') #删除临时文件再保存图片，如果点击了图片会返回图片名 if asksave == '保存图片' or asksave == 'temp.jpg': os.remove('temp.jpg') savepath = eg.filesavebox('选择需要保存的位置', title = title, default = 'newimage.jpg', filetypes = ['*.jpg']) if savepath == None:#点击取消或者X返回None ask = eg.buttonbox('要继续下载吗?', title, ('继续', '退出')) if ask == '继续': continue else: break else: with open(savepath, 'wb') as f: f.write(catimage) ask = eg.buttonbox('要继续下载吗?', title, ('继续', '退出')) if ask == '继续': continue else: break #如果不喜欢这个图片或者尺寸，删除之前的临时图片，再重新输入尺寸 elif asksave == '重新输入尺寸': os.remove('temp.jpg') continue #退出时也要删除临时文件 else: os.remove('temp.jpg') break elif size == None:#退出 break else:#输入错误时 feedback = eg.buttonbox('输入错误，请重新输入?', title, ('重新输入', '退出')) if feedback == '重新输入': continue else: break pyinstaller打包后：参考用PyInstaller-3.4打包python程序为exe程序 下载一个封面图片 预览图片 总结： 脚本写好了初次运行没有报错只是完成了一半，剩下一半或者更多的是调试，修改。 要坚持写笔记，对于一个普通人来讲很有用，如果你是天才请忽略。 今天又写了一篇文章记录使用Git, Markdown, Typora使用问题和解决方法。真的感觉Git很复杂，要慢慢理解，遇到问题再解决问题，在实践中学习。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>easygui</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫 利用Easygui和Pyinstaller写一个简单的字典]]></title>
    <url>%2FSonicHuang%2F8f8af010%2F</url>
    <content type="text"><![CDATA[基于上一篇文章《爬虫-有道词典》，我们用Easygui做一个简单的交互界面，用Pyinstaller打包成EXE文件，就可以方便传输和使用了。 1.先单独写一个easgui的脚本然后把字典脚本改成一个模块的形式导入就可以了。修改成模块的 youdao.py文件代码如下： 1234567891011121314151617181920212223242526272829'''本脚本是利用easygui的交互界面和youdao.py模块实现简单的词典功能。基于有道在线词典'''import easygui as egimport youdao as yd#定义相关参数，初始的输入框值为空白msg = '请输入你想查询的单词或句子\n支持英语，中文等'title = 'EvenRui小词典 v1.0 开发者:SonicHuang'words = ''meaning = ''while True: m = eg.multenterbox(msg, title,['请输入：', '意思是：'],[words, meaning]) if m != None and m[0] != '' and m[1] == '': #输入正确的状态是首先m的值不为None,在输入框有值，在'意思是'这一栏是空白. words = m[0]#再赋值给multenterbox的两个参数，使其同时显示单词和他的翻译结果。 meaning = yd.translate(words) m = eg.multenterbox(msg, title,['请输入：', '意思是：'],[words, meaning]) if m == None: #再点击cancel或者X者退出程序 break else: #点击ok 继续查询，参数为空白回到原始状态 words = '' meaning = '' continue else: #输入错误时，错误提示 ask1 = eg.buttonbox('输入错误，请在正确的位置重新输入。', title, ('重新查词', '退出词典')) if ask1 == '重新查词': words = '' meaning = '' continue else: break 2.把两个py文件放在同一个文件夹里，主程序为EvenRui.py, youdao.py为需要导入的模块, 然后CMD进入这个文件夹后，命令行输入pyinstaller -F -w EvenRui.py，具体使用方法参考我之前的文章 用PyInstaller-3.4打包python程序为exe程序。生成EXE文件后可以删除其他多余的文件。 3.双击EXE文件运行一切正常。4.总结： 运用导入模块的方法 运用pyinstaller,easygui]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>easygui</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫-有道词典]]></title>
    <url>%2FSonicHuang%2F118256ff%2F</url>
    <content type="text"><![CDATA[本文通过爬取有道词典，用python代码实现简单的翻译任务。 小甲鱼在教材中也讲了有道词典的爬取方法，但是时隔几年后的今天，有道工程师已经部署了反爬机制，对请求的表单数据进行了加密。如果不知道他们的加密方法，我们就会爬取失败，得到的数据是{‘errorCode’: 50} ， 或者请求非法等错误信息。一开始我也遭遇了同样的问题，通过反复的查资料不断的调试代码，虽然我不懂json, 也最终成功达到了我想要的目的。后面我们来看一下是怎么实现的。 我的配置： Python 3.7.0 window 7 简化版 ChromeVersion 69.0.3497.81 (Official Build) (32-bit) 1. Chrome打开有道在线翻译, 鼠标右键审查元素–Network–输入hello回车后就可以看到POST请求数据–点开左边的链接 2.点开链接后在Response我们可以看到有反馈的结果’你好’，返回到Headers就可以看到我们请求的地址Request URL 3.Headers下面图中Request Headers的Cookie, Referer, User-Agent后面的数据我们需要用到。 4.Headers最后面Form Data就是我们向服务器请求的数据，后面我们需要用python脚本把这些数据发到有道服务器。 请注意标注的四个参数，如果我们另外输入一个需要翻译的词语，会发现其中i, salt, sign, ts的数据是变化的。第二图与第一图比较就可以发现。我们需要知道变化的三个参数的规律，才能返回我们想要的结果。 5.找到定义这些参数的json文件，在Elements下面如图可以看到一个fanyi.min.js的json文件，复制他的地址在浏览器中打开，会发现很乱的文本。再复制所有文本到Json在线格式化工具,转化一下就比较清晰了。可以把转化后的文本在记事本中打开，查找salt的文本，就会发现相关的定义。 6.如下图，我们就可以找到ts, salt, sign的值。 我没有学过json以上的方法参考python3爬虫之有道翻译(上)，如有错误请指正。注意定义salt中最后一个字符串“p09@Bn{h02_BIEe]$P^nG”有可能会变化，根据实际情况而定。 7.知道表单参数的值后，我们根据小甲鱼的教材就可以编写Python脚本了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import urllib.request as urimport urllib.parse as upimport timeimport randomimport hashlibimport json#请求的地址：在第2步中的Request URLurl = 'http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule'#需要翻译的内容：content = input('Input what you want to translate:')#表单数据关键数据ts, salt, sign的计算方法client = 'fanyideskweb'ts = int(time.time() * 1000) num = random.randint(1, 10)#从1到10的随机数salt = str(ts) + str(num)flowerStr = 'p09@Bn&#123;h02_BIEe]$P^nG'sign = hashlib.md5((client + content + salt + flowerStr).encode('utf-8')).hexdigest()data = &#123;&#125;data['i'] = contentdata['from'] = 'AUTO'data['to'] = 'AUTO'data['smartresult'] = 'dict'data['client'] = clientdata['salt'] = salt #salt的值可以是时间戳和随机数数值相加的结果，也可以是对应字符串相加的结果。可以是int,也可以是strdata['sign'] = sign#sign的值是client(固定值),content(变化值),salt(变化值),固定字符串拼接后的md5值data['ts'] = ts #ts的值是一个时间戳，可以是int也可以是strdata['bv'] = '3e6546407cd5c219c8baa670735759b6' #bv是浏览器和版本信息的md5值data['doctype'] = 'json'data['version'] = '2.1'data['keyfrom'] = 'fanyi.web'data['action'] = 'FY_BY_CLICKBUTTION'data['typoResult'] = 'false'#解析表单数据并编码data = up.urlencode(data).encode('utf-8')#下面的header数据需要填入,并实例化req = ur.Request(url = url, data = data, method = 'POST')req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36')req.add_header('Referer', 'http://fanyi.youdao.com/')req.add_header('Cookie', 'OUTFOX_SEARCH_USER_ID=602357771@10.169.0.84')#请求并接受反馈信息, timeout是以秒单位确定连接的超时时间response = ur.urlopen(req, timeout = 5)#读取反馈信息并解码html = response.read().decode('utf-8')#利用json库把json数据转化为python的列表或者字典result = json.loads(html)['translateResult'][0][0]['tgt']print('The result is ==&gt;&gt; %s.' % result) Json和hashlib的用法参考：Python中的json库的简单使用 hashlib简介 总结： 没有学过json要做爬虫很被动，学爬虫本身就是被动的，昨天读了一片文章《爬虫VS反爬虫》，他们之前的内耗摧残着做这些工作的程序猿们，和消耗着网络上绝大多数的流量，浪费！所以我不打算把爬虫作为我今后主攻的方向。 一个人外部最大的敌人不是困难而是诱惑。面对诱惑，仍然坚守正道，才是高人。 知识都是相通的。要学好python，得了解很多其他方面的知识。 通过今天这段代码，了解了json, urllib.parse包，hashlib库]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>urllib</tag>
        <tag>json</tag>
        <tag>hashlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫-访问网站数据并保存在对应文件]]></title>
    <url>%2FSonicHuang%2F183747d7%2F</url>
    <content type="text"><![CDATA[题目：访问网址读取数据并保存在对应的文本文件里 我的代码：12345678910111213141516171819'''此脚本通过读取urls.txt上的网站的信息，并保存在对应的文本文件里。'''import urllib.request as urimport chardet as chdef main(): with open('urls.txt') as file: urls = file.readlines()#分行读取 n = 0 for url in urls: sources = ur.urlopen(url).read() code = ch.detect(sources)['encoding']#检测网站的编码方式 html = sources.decode(code)#对网站信息进行相应的解码,decode默认的是encoding = 'utf-8'的编码 n += 1 filename = ''.join(['file_', str(n), '.txt'])#生成对应的文件 with open(filename, 'w', encoding = code) as nfile:#再用相应的编码写入对应的文件，encoding默认的编码是utf-8 nfile.write(html)if __name__ == '__main__': main() 老师的代码：123456789101112131415161718192021222324252627282930'''读取网站信息并保存在对应的文件里。老师的方法与我的相似，不同之处，读取网站信息时使用了分割换行符的方法'''import urllib.requestimport chardetdef main(): i = 0 with open("urls.txt", "r") as f: # 读取待访问的网址 # 由于urls.txt每一行一个URL # 所以按换行符'\n'分割 urls = f.read().splitlines() for each_url in urls: response = urllib.request.urlopen(each_url) html = response.read() # 识别网页编码 encode = chardet.detect(html)['encoding'] if encode == 'GB2312': encode = 'GBK' i += 1 filename = "url_%d.txt" % i #老师用了格式化，我用了join的方法 with open(filename, "w", encoding=encode) as each_file: each_file.write(html.decode(encode, "ignore")) #decode的第二个参数。对于有些字符的特殊编码方式，我们可以通过这个方式进行忽略,详细请参考后面链接。if __name__ == "__main__": main() 以下内容参考：Python中解码decode()与编码encode()与错误处理UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0xab 使用python的时候经常会遇到文本的编码与解码问题，其中很常见的一种解码错误如题目所示，下面介绍该错误的解决方法，将‘gbk’换成‘utf-8’也适用。（1）、首先在打开文本的时候，设置其编码格式，如：open(‘1.txt’,encoding=’gbk’)；（2）、若（1）不能解决，可能是文本中出现的一些特殊符号超出了gbk的编码范围，可以选择编码范围更广的‘gb18030’，如：open(‘1.txt’,encoding=’gb18030’)；（3）、若（2）仍不能解决，说明文中出现了连‘gb18030’也无法编码的字符，可以使用‘ignore’属性进行忽略，如：open(‘1.txt’,encoding=’gb18030’，errors=‘ignore’)； （4）、还有一种常见解决方法为open(‘1.txt’).read().decode(‘gb18030’,’ignore’ 总结： 复习了文件的读取与写入 decode 与 encode 的应用 urllib 与 chardet的应用]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>chardet</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫-编码检测应用]]></title>
    <url>%2FSonicHuang%2Fbd5cd896%2F</url>
    <content type="text"><![CDATA[上一篇我们安装编码检测工具chardet, 小甲鱼老师有道题要求用户输入任意网址，我们通过脚本判断出该网站使用的编码方式。 题目演示： 下面是我的代码：123456789101112131415161718192021222324252627282930'''本脚本是利用文本编码检测工具chardet检测用户输入的网站所使用的编码。'''import urllib.request as urimport chardet as ch#定义一个函数用于接收网站数据def source(): url = input('Please input the URL you want to detect: ') try:#检测用户输入的网址是否正确 content = ur.urlopen(url).read() except: print('The URL is wrong or it\'s not available.') else: return content#检测网站的编码def detect(): try:#如果用户输入的网址有问题这里就会抛出异常，为了使脚本运行正常，这里进行了处理，并提示用户。 sources = source() result = ch.detect(sources) except: print('You should restart the application again.') else: result = result['encoding'] if result == 'GB2312': result = 'GBK' print('The encoding way is %s.' % result)#如果作为单独脚本运行时if __name__ == '__main__': detect() 参考关于GB2312 和 GBK 总结： 要注意 1__name__ == '__main__': 的使用]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>chardet</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中安装编码检测工具chardet]]></title>
    <url>%2FSonicHuang%2Fb9b1e485%2F</url>
    <content type="text"><![CDATA[在Github建好博客后开始学习新的一章，爬虫，首先需要安装一个检测网页代码编码的工具chardet. 参考chardet官网 1. pip 安装在cmd输入命令 1pip install chardet 2. 使用detect()模块检测在IDLE 12345&gt;&gt;&gt; import urllib.request as ur&gt;&gt;&gt; respond = ur.urlopen('https://sonichuang.github.io')&gt;&gt;&gt; import chardet&gt;&gt;&gt; chardet.detect(respond.read())&#123;'encoding': 'utf-8', 'confidence': 0.99, 'language': ''&#125; 意思百分之九十九是utf-8, 还可以检测字符串的语言，如：中文，英文等]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>chardet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Github博客加入博客背景 评论功能以及修改侧栏]]></title>
    <url>%2FSonicHuang%2F2be1fd41%2F</url>
    <content type="text"><![CDATA[一.加入博客背景1. 找到主博客\themes\next\source\css_custom下custom.styl文件，原始文件里面是空白的，用记事本打开然后添加如下文本。 123456789101112131415// Custom styles.@media screen and (min-width:1200px) &#123; body &#123; background-image:url(/images/backgroundpicturename.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover &#125; #footer a &#123; color:#eee; &#125;&#125; 注意上面url后面括号里面内容。 2.把需要的背景图片放在\themes\next\source\images文件夹里然后把图片名称填入步骤1，url后面backgroundpicturename,注意扩展名例子是jpg, 要根据实际情况修改。3. 部署后就可以看到我们的背景了。我把图片进行了修改，在图片编辑器里面修改他的像素为电脑屏幕的实际像素值。 4. 如果感觉背景图片会挡住博客上的字可以调节，图片的透明度。在步骤1的文件中下面加入如下代码，12345//background color and opacity.main-inner &#123; background: #fff; opacity: 0.9;&#125; background后面的值是颜色代码，这里是白色。opacity是指透明度。这里可以根据需要进行调整。 二. 加入评论功能1.网上推荐使用LiveRe, 在其主页申请一个免费帐号，再Install(安装)，city(一般网站)就可以得到一串代码注意data-uid后面引号里面的字符串。 2.再打开主目录下\themes\next的配置文件_config.yml文件找到如下内容，然后在your uid后面填上步骤1的字符串，注意不要引号，并去掉livere uid前面的#。部署好就可以了。 三. 修改侧栏目录的显示在打开某一个文章的时候，侧栏老是在显示（下图一）如果想把隐藏掉。可以这样修改，在主目录下主题的配置文件\themes\next， _config.yml中sidebar display中在post值那里最前面加上#, 再去掉hide前的#, 就可以了（如下图二） 总结：修改博客背景，添加评论功能，修改侧栏目录的显示方式]]></content>
      <categories>
        <category>github pages</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Typora中插入本地图片和加入Readmore按钮]]></title>
    <url>%2FSonicHuang%2F58b77a70%2F</url>
    <content type="text"><![CDATA[第一部分：插入本地图片我现在遇到的问题是：在用Typora编辑MD时，插入本地图片后，不能在网页上显示, 只能看到空白的方框。 我的博客是用Hexo搭建，使用next主题，用的windows系统，苹果电脑有个专门的软件叫ipic听说很好用，但是windows却没有。图片不能显示的原因是：本地插入的图片在Typora本地是图片的绝对地址，部署到网站后，还是显示的绝对路径，很明显，系统找不到这个地址，也就不能显示图片了。解决的方法在网上也是很多，比如安装插件，修改配置文件等等，我觉得太复杂，其实最简单的办法只要简单的几步: 1. 在博客根目录下&gt;source下新建一个assets文件夹。 2.在Typora&lt;File&lt;Preference选择如下： a. 第一个拷贝图片到指定文件夹b. 第二个选择步骤1的assets文件夹，意思是拖放到Typora中的图片会自动复制到这个assets文件夹。c. 第三，四指适用于拖入的本地图片和网络图片都会复制到assets文件夹d. 第五，使用相对路径3. 在Typora&lt;Edit&lt;Image Tools&lt;Use Image Root Path在这里选择储存图片的根目录，定位到步骤1的source文件夹，不能定位到放图片的assets文件夹，我之前就把这步弄错了，导致网站上不能显示图片。定位好后会在Typora的MD文件头里面出现如图的语句： 4.设置好了后就就可以插入图片了，显示的是图片的相对路径。 5. 部署后就能在网站正确显示了。第二部分：在博客首页加入Readmore按钮有两个办法： 1. 手动添加（推荐），在MD文中的适当位置重启一行纯文本写入如下图这一行，系统就会自动在首页显示之前的内容 2. 自动添加。在主题文件夹的配置文件\themes\next下面_config.yml，中找到如下代码： 实际上官方推荐使用手动加入Readmore按钮。因为自动添加会让文章看起来不人性化, 会出现突然在某个地方咔嚓一下断掉的感觉。另外如果同时设置的手动和自动，会优先在手动的地方显示。 总结：1. 网络上的方法不一定适合自己，所以需要不断试错。2. 不要轻易放弃。3. 本文章解决了Typora编写MD后部署到Github后图片显示不正常的问题以及加入Readmore按钮的方法。本文参考：关于Typora和hexo图片路径的问题]]></content>
      <categories>
        <category>github pages</category>
      </categories>
      <tags>
        <tag>typora</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新安卓平板固件]]></title>
    <url>%2FSonicHuang%2F379f2134%2F</url>
    <content type="text"><![CDATA[本篇文章单纯为了记录安卓平板固件的更新过程。 之前为了让小孩子的英语作业能够一天多做一点，而寻求通过一些方法修改安卓app的对于时间上的限制，想了很多办法想让平板ROOT后，获取更多的权限。但是最终下载下来的固件，通过Odin重装后机子都无法正常启动。最后看到网上有人讲SM T700的平板升级到这个安卓版本6.0.1后几乎没有办法ROOT，而且后来得知App是部署在服务器上的，没有办法通过修改App的程序改变限制。 但是现在机子几乎变砖，怎么也要把它救过来。 1. 下载平板对应版本的固件。固件下载地址 2. 下载Odin官方下载地址 3. 在AP处添加步骤1的文件，其他参数不用修改。4. 按住平板电源键，音量下键，和Home键几秒中就可以看到下载模式，再按音量上键就开始启动下载。5. 用数据线连接平板和电脑，然后点击Odin3， Start.6. 直到平板安装完成重启，Odin3显示Pass，结束。 结束语：1.第一次使用Typora编辑MD文档，感觉很方便，比想象的更方便。但是现在还有一个问题没有解决，就是在Typora中插入本地的图片然后部署后能够正确的显示。2. 三星平板真难用，按照上面的步骤更新后发现还是启动不了，后来再启动Recovery模式，按住电源键，音量上键和Home。恢复到出厂设置才解决问题。3. 遇到困难的时候，在将要放弃的时候再坚持一下，问题就解决了。]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ROM</tag>
        <tag>Record</tag>
      </tags>
  </entry>
</search>
